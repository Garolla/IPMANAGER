DEVELOPING IP CORES FOR TESTING
* In order to verify the correct behavior of the system, we develop a few simple IP cores.
* We can test that the management of transactions follows specifications and that the whole system is synthesizable.

REGULAR OPERATION: ADDER IP
* Test regular transactions through the data buffer (no interrupts)
* Core: a simple adder
* 3 reserved data positions in the buffer:
	- OPERAND1 (CPU out, IP core in)
	- OPERAND2 (CPU out, IP core in)
	- RESULT (CPU in, IP core out)
* The core works as a FSM cycling through a few states

1 : IDLE
* This state is entered at reset
* The adder stays in IDLE whenever enable = 0
* In this state, the core requests to read op1 from address row 1

2: READ_OPERAND2
* This state is entered as soon as enable becomes = 1
* The core requests to read op2 from address row 2

3: WRITE_OPERAND1
* Since the IPM stands between the core and the data buffer, effectively pipelining the signals, there is a 1-cc latency between the request to read OP1 and the reception.
* After sending the request for OP2, we should receive OP1 on data_out
* We store it in a local register while waiting for OP2 to arrive

4: WRITE_RESULT
* On this cycle we receive OP2 from the data buffer
* The behavioral adder directly computes the result and we write it to the buffer's data_in
* We return to IDLE after this state, and the cycle repeats

SOME TIMING DETAILS
* In order to complete the sum, the CPU must keep the transaction open (adder's enable = 1) for 4 clock cycles
* If the adder is enabled for more than 4 clock cycles, the core cycles back to idle and reads OP1. If it is still enabled after that, it can compute a new sum without interruptions or additional delay.
* If the transaction is enabled for less than 3 cycles, the core stops operation and goes back to idle. No result is written back.